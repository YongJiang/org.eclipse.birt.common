/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*/options
{
                                                  
                                                  

                                                                
               

       
                                                              
                                                              
                                                      
                                                        
                                                       
                                                   
                
       
                          

    /**
     * The parser must be non-static in order for the
     * above option to work, otherwise the parser value
     * is passed in as null, which isn't all the useful ;)
     */
    STATIC=false;

       
                                                      
                                                      
                                                     
                                                   
                                                  
       
                 

    /**
     * Declare that we are accepting unicode input and
     * that we are using a custom character stream class
     * Note that the char stream class is really a slightly
     * modified ASCII_CharStream, as it appears we are safe
     * because we only deal with pre-encoding-converted
     * Readers rather than raw input streams.
     */
    UNICODE_INPUT=true;

    /**
     *  for debugging purposes.  Keep false
     */
    DEBUG_PARSER=false;
    DEBUG_TOKEN_MANAGER=false;
}

PARSER_BEGIN(Parser)

package org.eclipse.birt.core.template;

import java.io.*;
import java.util.*;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/
    public Parser()
    {
		this((Reader)null);
    }

    public ASTTemplate parse( Reader reader )
        throws ParseException
    {
    	ReInit(reader);
    	Template();
    	return (ASTTemplate)jjtree.rootNode();
    }
}
PARSER_END(Parser)



/* ------------------------------------------------------------------------
 *
 * Tokens
 *
 *  Note : we now have another state, REFMODIFIER.  This is sort of a
 *  type of REFERENCE state, simply use to use the DIRECTIVE token
 *  set when we are processing a $foo.bar() construct
 *
 * ------------------------------------------------------------------------- */
SKIP :
{
	<		( " " | "\t" | "\n" | "\r" )+	>
}

TOKEN [IGNORE_CASE] :
{
	<START_VALUEOF:		        "<value-of"				>	: ATTLIST
|	<END_VALUEOF:		        "</value-of"			>	: ATTLIST
|	<START_VIEWTIMEVALUEOF:		"<viewtime-value-of"	>	: ATTLIST
|	<END_VIEWTIMEVALUEOF:		"</viewtime-value-of"	>	: ATTLIST
|	<START_IMAGE:		        "<image"				>	: ATTLIST
|	<END_IMAGE:			        "</image"				>	: ATTLIST
|	<TEXT:				        ( ~["<"] )+	| "<"		>
}

<ATTLIST> SKIP :
{
	<		" " | "\t" | "\n" | "\r" 	>
}

<ATTLIST> TOKEN :
{
	<TAGC:		">"				>	: DEFAULT
|   <ELEMENTC:  "/>"            >   : DEFAULT
|	<A_EQ:		"="				>	: ATTRVAL

|	<#ALPHA:	["a"-"z","A"-"Z","_","-","."]	>
|	<#NUM:		["0"-"9"]			>
|	<#ALPHANUM:	<ALPHA> | <NUM>			>
|	<A_NAME:	<ALPHA> ( <ALPHANUM> )*		>

}

<ATTRVAL> TOKEN :
{
	<CDATA:		"'" ( ~["'"] )* "'"
		|	"\"" ( ~["\""] )* "\""
		| ( ~[">", "\"", "'", " ", "\t", "\n", "\r"] )+
							>	: ATTLIST
}

void Attribute() :
{/*@bgen(jjtree) Attribute */
        ASTAttribute jjtn000 = new ASTAttribute(this, JJTATTRIBUTE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token n, v;
}
{/*@bgen(jjtree) Attribute */
        try {
/*@egen*/
	n=<A_NAME> <A_EQ> v=<CDATA>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.setName(n.image);
		jjtn000.setValue(v.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Ebody_content() : {/*@bgen(jjtree) Ebody_content */
  ASTEbody_content jjtn000 = new ASTEbody_content(this, JJTEBODY_CONTENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Ebody_content */
        try {
/*@egen*/
	(	Text( )	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Image() : {/*@bgen(jjtree) Image */
  ASTImage jjtn000 = new ASTImage(this, JJTIMAGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Image */
        try {
/*@egen*/
	<START_IMAGE> ( Attribute() )* 
		(<ELEMENTC>
		| 
		( <TAGC>
			Ebody_content()
			<END_IMAGE> <TAGC>))/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ValueOf() : {/*@bgen(jjtree) ValueOf */
  ASTValueOf jjtn000 = new ASTValueOf(this, JJTVALUEOF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ValueOf */
        try {
/*@egen*/
	<START_VALUEOF> ( Attribute() )* <TAGC>
	Ebody_content()
	<END_VALUEOF> <TAGC>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ViewTimeValueOf() : {/*@bgen(jjtree) ViewTimeValueOf */
  ASTViewTimeValueOf jjtn000 = new ASTViewTimeValueOf(this, JJTVIEWTIMEVALUEOF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ViewTimeValueOf */
        try {
/*@egen*/
	<START_VIEWTIMEVALUEOF> ( Attribute() )* <TAGC>
	Ebody_content()
	<END_VIEWTIMEVALUEOF> <TAGC>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Text() : 
{/*@bgen(jjtree) Text */
        ASTText jjtn000 = new ASTText(this, JJTTEXT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token text;
}
{/*@bgen(jjtree) Text */
        try {
/*@egen*/
	text = <TEXT>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
		jjtn000.appendContent(text.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Template() : {/*@bgen(jjtree) Template */
  ASTTemplate jjtn000 = new ASTTemplate(this, JJTTEMPLATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Template */
        try {
/*@egen*/
	( LOOKAHEAD(2)
		(	LOOKAHEAD(9) ValueOf()
|			LOOKAHEAD(9) ViewTimeValueOf()
|			LOOKAHEAD(6) Image()
|			LOOKAHEAD(2) Text()
		)
	) */*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}